템플릿 메서드 패턴으로 해결한 동일한 문제를 전략 패턴을 통해 해결해보자.
핵심은 상속이 아닌 **위임**으로 문제를 해결하는 것이다.

![[Pasted image 20251010164456.png]](../images/Pasted%20image%2020251010164456.png)

템플릿 메서드 패턴에서는 개별 로직을 자식 객체가 추상 메서드를 구현하는 형태로 구현했다.
반면 전략 패턴에서는 개별 로직을 인터페이스 구현체가 구현한다.

#### 템플릿 메서드 패턴과의 차이
```
1. 템플릿 메서드 패턴은 상속을 사용하기 때문에 자식 객체(개별 로직 수행 주체)가 부모에게 종속적이다. 클래스 단위에서 의존 관계가 형성

2. 전략 패턴의 경우 공통 로직 수행 주체와 개별 로직 수행 주체가 완전히 독립적이다.
쉽게 말해 MaskingContext 와 MaskingStrategey 구현체는 완전히 독립적이다.
다시 말해 MaskingContext 가 변경된다고 해서 MaskingStrategey 구현체에 영향을 주지 않는다.
```

##### 정말로 영향을 주지 않는가?
- 만약 공통 로직에서 개별 로직 수행에 영향을 주도록 코드를 짜면 전략 패턴을 사용하더라도 영향을 줄 수는 있다. 예를 들어 개별 로직을 수행하는 `call()` 메서드가 이와 같이 인자를 하나 받는다고 하자 `maskingStrategy.call(something)` 
- 그리고 `someting` 이라는 데이터는 공통 로직에서 만든다고 하면 영향을 줄 수 있다. 다만 이는 설계를 잘못한 것이기 논외라고 생각한다.
